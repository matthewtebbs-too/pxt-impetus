"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var child_process = require("child_process");
var fs = require("fs");
var net = require("net");
var U = pxt.Util;
function fatal(msg) {
    U.userError(msg);
}
function getOpenOcdPath() {
    function latest(tool) {
        var dir = pkgDir + "tools/" + tool + "/";
        if (!fs.existsSync(dir))
            fatal(dir + " doesn't exists; " + tool + " not installed in Arduino?");
        var subdirs = fs.readdirSync(dir);
        if (!subdirs.length)
            fatal("no sub-directories in " + dir);
        subdirs.sort(pxt.semver.strcmp);
        subdirs.reverse();
        var thePath = dir + subdirs[0] + "/";
        if (!fs.existsSync(thePath + "bin"))
            fatal("missing bindir in " + thePath);
        return thePath;
    }
    var dirs = [
        process.env["HOME"] + "/Library/Arduino",
        process.env["USERPROFILE"] + "/AppData/Local/Arduino",
        process.env["HOME"] + "/.arduino",
    ];
    var pkgDir = "";
    for (var ardV = 15; ardV < 50; ++ardV) {
        for (var _i = 0, dirs_1 = dirs; _i < dirs_1.length; _i++) {
            var d = dirs_1[_i];
            pkgDir = d + ardV + "/packages/arduino/";
            if (fs.existsSync(pkgDir))
                break;
            pkgDir = "";
        }
        if (pkgDir)
            break;
    }
    if (!pkgDir)
        fatal("cannot find Arduino packages directory");
    var openocdPath = latest("openocd");
    var openocdBin = openocdPath + "bin/openocd";
    if (process.platform == "win32")
        openocdBin += ".exe";
    var script = pxt.appTarget.compile.openocdScript;
    if (!script)
        fatal("no openocdScript in pxtarget.json");
    var cmd = "log_output built/openocd.log; " + script + "; init; halt;";
    var args = [openocdBin, "-d2",
        "-s", openocdPath + "/share/openocd/scripts/",
        "-c", cmd];
    var gccPath = latest("arm-none-eabi-gcc");
    var gdbBin = gccPath + "bin/arm-none-eabi-gdb";
    if (process.platform == "win32")
        gdbBin += ".exe";
    return { args: args, gdbBin: gdbBin };
}
function startAsync(gdbArgs) {
    var cs = pxt.appTarget.compileService;
    var f = cs.codalBinary ?
        "built/codal/build/" + cs.codalBinary :
        "built/yt/build/" + cs.yottaTarget + "/source/" + cs.yottaBinary.replace(/\.hex$/, "").replace(/-combined$/, "");
    if (!fs.existsSync(f))
        fatal("compiled file not found: " + f);
    var toolPaths = getOpenOcdPath();
    var oargs = toolPaths.args;
    fs.writeFileSync("built/openocd.gdb", "\ntarget extended-remote localhost:3333\ndefine rst\n  set {int}(0x20008000-4) = 0xf02669ef\n  monitor reset halt\n  continue\nend\ndefine irq\n  echo \"Current IRQ: \"\n  p (*(int*)0xE000ED04 & 0x1f) - 16\nend\necho Use 'rst' command to re-run program from start (set your breakpoints first!).\\n\n");
    pxt.log("starting openocd: " + oargs.join(" "));
    var oproc = child_process.spawn(oargs[0], oargs.slice(1), {
        stdio: "inherit",
        detached: true,
    });
    var gdbargs = ["--command=built/openocd.gdb", f].concat(gdbArgs);
    pxt.log("starting gdb with: " + toolPaths.gdbBin + " " + gdbargs.join(" "));
    var proc = child_process.spawn(toolPaths.gdbBin, gdbargs, {
        stdio: "inherit",
    });
    process.on('SIGINT', function () {
        // this doesn't actully kill it, it usually just stops the target program
        proc.kill('SIGINT');
    });
    var shutdownOpenocdAsync = function () { return new Promise(function (resolve, reject) {
        var s = net.connect(4444);
        s.on("connect", function () {
            pxt.log("shutdown openocd...");
            s.write("shutdown\n");
            s.end();
        });
        s.on("error", function () {
            pxt.log("Cannot connect to openocd to shut it down. Probably already down.");
            resolve();
        });
        s.on("close", function () { return resolve(); });
    }); };
    var start = Date.now();
    return new Promise(function (resolve, reject) {
        proc.on("error", function (err) { reject(err); });
        proc.on("close", function () {
            resolve();
        });
    })
        .finally(function () { return Promise.delay(Math.max(0, 2000 - (Date.now() - start)))
        .then(shutdownOpenocdAsync); });
}
exports.startAsync = startAsync;
